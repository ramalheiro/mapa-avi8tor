<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Comparativo de Alcance de Aeronaves</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
<style>
  body, html { margin:0; padding:0; height:100%; }
  #map { width:100%; height:100%; }
  .label {
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 12px;
    font-family: sans-serif;
    white-space: nowrap;
    text-align: center;
  }
  .city-point {
    width: 12px;
    height: 12px;
    background: #000;
    border: 2px solid #fff;
    border-radius: 50%;
  }
</style>
</head>
<body>
<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoicmFtYWxoZWlybyIsImEiOiJjbWZtdmN4OTcwNmM3Mm1vbDhtY3UxZ2ViIn0.7xL1bz2EaA_L5CHtBb9Ruw';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/light-v11',
  center: [-47.9, -15.8],
  zoom: 4
});

// Função para gerar círculo aproximado em GeoJSON
function createCircle(center, radiusKm, points = 128) {
  const coords = [];
  const [lon, lat] = center;
  const R = 6371; // raio da Terra em km

  for (let i = 0; i <= points; i++) {
    const angle = (i / points) * (2 * Math.PI);
    const dx = radiusKm / R * Math.cos(angle);
    const dy = radiusKm / R * Math.sin(angle);

    const newLat = lat + (dy * 180 / Math.PI);
    const newLon = lon + (dx * 180 / Math.PI) / Math.cos(lat * Math.PI/180);
    coords.push([newLon, newLat]);
  }

  return {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [coords] }
  };
}

// Parse múltiplos círculos
function parseCircles() {
  const params = new URLSearchParams(window.location.search);
  const circlesStr = params.get("circles");
  if (!circlesStr) return [];

  const groups = circlesStr.split(";");
  const parsed = [];

  for (const g of groups) {
    const parts = g.split(",").map(p => p.trim());
    if (parts.length < 7) {
      console.warn("Parâmetros inválidos ignorados:", g);
      continue;
    }

    const [icao, latStr, lonStr, city, radiusNMStr, aircraft, color] = parts;
    const lat = parseFloat(latStr), lon = parseFloat(lonStr);
    const radiusNM = parseFloat(radiusNMStr);

    if ([lat, lon, radiusNM].some(v => isNaN(v))) {
      console.warn("Coordenadas inválidas:", g);
      continue;
    }

    const radiusKM = radiusNM * 1.852;

    parsed.push({
      icao, city, aircraft, color: color || "#007cbf",
      radiusNM, radiusKM,
      center: [lon, lat]
    });
  }

  return parsed;
}

const circles = parseCircles();

map.on("load", () => {
  if (!circles.length) {
    console.log("Nenhum círculo encontrado.");
    return;
  }

  let allBounds = null;

  circles.forEach((c, idx) => {
    const feature = createCircle(c.center, c.radiusKM);

    const sourceId = `circle-${idx}`;
    map.addSource(sourceId, { type: "geojson", data: feature });

    map.addLayer({
      id: `${sourceId}-fill`,
      type: "fill",
      source: sourceId,
      paint: {
        "fill-color": c.color,
        "fill-opacity": 0.2
      }
    });

    map.addLayer({
      id: `${sourceId}-outline`,
      type: "line",
      source: sourceId,
      paint: {
        "line-color": c.color,
        "line-width": 2
      }
    });

    // Label da aeronave na borda (N, L, O, S)
    const [lon, lat] = c.center;
    const offsetKm = c.radiusKM;
    let labelPos;

    switch (idx % 4) {
      case 0: // Leste
        labelPos = [lon + (offsetKm / 111), lat];
        break;
      case 1: // Norte
        labelPos = [lon, lat + (offsetKm / 111)];
        break;
      case 2: // Oeste
        labelPos = [lon - (offsetKm / 111), lat];
        break;
      case 3: // Sul
        labelPos = [lon, lat - (offsetKm / 111)];
        break;
    }

    // Criar label da aeronave
    const el = document.createElement("div");
    el.className = "label";
    el.innerText = `${c.aircraft}\n${c.radiusKM.toFixed(0)} km | ${c.radiusNM} nm`;

    new mapboxgl.Marker({ element: el, anchor:"center" })
      .setLngLat(labelPos)
      .addTo(map);

    // Criar label no centro com nome da cidade
    const cityEl = document.createElement("div");
    cityEl.className = "label";
    cityEl.innerText = c.city;

    new mapboxgl.Marker({ element: cityEl, anchor:"bottom", offset:[0, -15] })
      .setLngLat(c.center)
      .addTo(map);

    // Criar ponto no centro da cidade
    const pointEl = document.createElement("div");
    pointEl.className = "city-point";

    new mapboxgl.Marker({ element: pointEl, anchor:"center" })
      .setLngLat(c.center)
      .addTo(map);

    // Expand bounds
    const bounds = feature.geometry.coordinates[0].reduce(
      (b, coord) => b.extend(coord),
      new mapboxgl.LngLatBounds(feature.geometry.coordinates[0][0], feature.geometry.coordinates[0][0])
    );

    allBounds = allBounds ? allBounds.extend(bounds) : bounds;
  });

  if (allBounds) {
    map.fitBounds(allBounds, { padding: 80 });
  }
});
</script>
</body>
</html>
